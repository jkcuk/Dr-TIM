package math.ODE;public class RungeKuttaCashKarp{	private double		t, dt, dtnext;		// adapted from function rkqs (Numerical Recipes in C, p. 719)	// Fifth-order Runge-Kutta step with monitoring of local truncation error to ensure	// accuracy and adjust stepsize.  Input are the dependent variable array	// f[0,1,...] and its derivative dfdt[...] at the starting value of	// the independent variable t.  Also input are the stepsize to be attempted, dttry,	// the requred accuracy, eps, and the array fscal[...] against which the error	// is scaled.  On output, f is replaced by its new value, the variable this.t is set	// to the new value of t, this.dt is the stepsize that was actually accomplished, and	// this.dtnext is the estimated next stepsize.	// derivs is the user-supplied implementation of Derivatives2D that computes the	// right-hand side derivatives.	public void calculateQualityControlledRungeKuttaStep	(		double f[],		double dfdt[],		double t,		double dttry,		double eps,		double fscal[],		Derivatives derivs	)	{		final double			safety = 0.9,			pgrow = -0.2,			pshrink = -0.25,			errcon = 1.89e-4; // (5/safety) raised to the power (1/pgrow), see use below		int			xMax = f.length,			x;		double			errmax, dttemp;			//tnew;		double			ferr[] = new double[xMax],			ftemp[] = new double[xMax];				dt = dttry; // set stepsize to the initial trial value		for(;;)		{			// take a step			calculateRungeKuttaCashKarpStep(f, dfdt, t, dt, ftemp, ferr, derivs);						// evaluate accuracy			errmax = 0.0;			for(x=0; x<xMax; x++) errmax = Math.max(errmax, Math.abs(ferr[x]/fscal[x]));						// scale relative to required tolerance			errmax /= eps;						if(errmax <= 1.0)				// step succeeded				break;						// truncation error too large, reduce stepsize			dttemp = safety*dt*Math.pow(errmax, pshrink);						// no more than a factor of 10			dt = (dt >= 0.0 ? Math.max(dttemp, 0.1*dt) : Math.min(dttemp, 0.1*dt));						this.t = t + dt;			if(this.t == t)				throw new Error("stepsize underflow in calculateQualityControlledRungeKuttaStep");		}				// compute size of next step		if(errmax > errcon) dtnext = safety*dt*Math.pow(errmax, pgrow);		else dtnext = 5.0*dt;				this.t = t + dt;				for(x=0; x<xMax; x++) f[x] = ftemp[x];	}	// adapted from function rkck (Numerical Recipes in C, p. 719)	// Given values f[0,1,...] and their derivatives dfdt[...] known at t,	// use the fifth-order Cash-Karp Runge-Kutta method to advance the solution over an	// interval dt and return the incremented variables as fOut[...].	// Also return an estimate of the local truncation error in fOut[] using the	// embedded fourth-order method.  The user supplies derivs, an implementation of	// Derivatives, which supplies a method that returns derivatives df/dt at t.	private void calculateRungeKuttaCashKarpStep	(		double f[],		double dfdt[],		double t,		double dt,		double fOut[],		double fErr[],		Derivatives derivs	)	{		final double			a2=0.2, a3=0.3, a4=0.6, a5=1.0, a6=0.875,			b21=0.2,			b31=3.0/40.0,       b32=9.0/40.0,			b41=0.3,            b42=-0.9,        b43=1.2,			b51=-11.0/54.0,     b52=2.5,         b53=-70.0/27.0,    b54=35.0/27.0,			b61=1631.0/55296.0, b62=175.0/512.0, b63=575.0/13824.0, b64=44275.0/110592.0,			                                                            b65=253.0/4096.0,			c1=37.0/378.0, c3=250.0/621.0, c4=125.0/594.0, c6=512.0/1771.0,			dc1=c1-2825.0/27648.0, dc3=c3-18575.0/48384.0, dc4=c4-13525.0/55296.0,			dc5=-277.0/14336.0, dc6=c6-0.25;		int			xMax = f.length, x;				// allocate memory for ak2, ..., ak6		double			ak2[] = new double[xMax],			ak3[] = new double[xMax],			ak4[] = new double[xMax],			ak5[] = new double[xMax],			ak6[] = new double[xMax],			temp[] = new double[xMax];				// calculate ak2 = k2/dt		for(x=0; x<xMax; x++)			temp[x] = f[x] + b21*dt*dfdt[x];		derivs.calculateDerivatives(t+a2*dt, temp, ak2);				// calculate ak3 = k3/dt		for(x=0; x<xMax; x++)			temp[x] = f[x] + dt*(b31*dfdt[x] + b32*ak2[x]);		derivs.calculateDerivatives(t+a3*dt, temp, ak3);				// calculate ak4 = k4/dt		for(x=0; x<xMax; x++)			temp[x] = f[x] + dt*(b41*dfdt[x] + b42*ak2[x] + b43*ak3[x]);		derivs.calculateDerivatives(t+a4*dt, temp, ak4);				// calculate ak5 = k5/dt		for(x=0; x<xMax; x++)			temp[x] = f[x] + dt*(b51*dfdt[x] + b52*ak2[x] + b53*ak3[x] + b54*ak4[x]);		derivs.calculateDerivatives(t+a5*dt, temp, ak5);				// calculate ak6 = k6/dt		for(x=0; x<xMax; x++)			temp[x] = f[x] + dt*(b61*dfdt[x] + b62*ak2[x] + b63*ak3[x] + b64*ak4[x] + b65*ak5[x]);		derivs.calculateDerivatives(t+a6*dt, temp, ak6);				// accumulate increments with proper weights		for(x=0; x<xMax; x++)			fOut[x] = f[x] + dt*(c1*dfdt[x] + c3*ak3[x] + c4*ak4[x] + c6*ak6[x]);				// estimate error as difference between fourth and fifth order methods		for(x=0; x<xMax; x++)			fErr[x] = dt*(dc1*dfdt[x] + dc3*ak3[x] + dc4*ak4[x] + dc5*ak5[x] + dc6*ak6[x]);	}}